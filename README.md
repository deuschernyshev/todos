# todos

## Архитектура проекта

### Структура проекта

Наше приложение разделено на две основные секции: `feature` и `shared`. В папке `feature` располагаются все функциональные модули (например, Todo), а в папке `shared` находятся общие компоненты проекта, такие как API-клиент, роутер и UI-утилиты.

Важно отметить, что в данной статье не рассматривается реализация роутинга, API-клиента и других общих компонентов. В конце статьи будет предоставлена ссылка на репозиторий, где можно ознакомиться с полной реализацией.

## Библиотеки

Для реализации этого функционала мы будем использовать следующие библиотеки:

- **BloC** для управления состоянием.
- **GoRouter** для навигации.
- **JsonSerializable** для кодогенерации.
- **meta**, **dart_collection**, **uuid** для вспомогательных утилит.

Мы не используем такие библиотеки, как `get_it`, `freezed` или `equatable`. Этот проект предназначен для демонстрации минимальной и понятной реализации, однако вы можете выбрать любые другие зависимости в своем проекте.

## Описание фичи

Наш функционал состоит из нескольких слоев:

- **Presentation (представление)** — отвечает за отображение данных и взаимодействие с пользователем.
- **Domain (доменный слой)** — содержит бизнес-логику.
- **Data (данные)** — взаимодействует с внешними источниками данных.

В структуре папки `todos` на уровне фичи находятся следующие папки и файлы:

- **presentation**:
  - **screens**: Экран отображения списка задач и экран для создания/редактирования задач.
  - **widgets**: Общие виджеты для использования на разных экранах.
  - **scope**: Обработчик зависимостей для экрана.
- **domain**:
  - **entities**: Сущности данных приложения.
  - **usecases**: Операции, которые могут выполнять пользователи.
  - **repositories**: Контракт для доступа к данным.
- **data**:
  - **models**: Модели данных, соответствующие сущностям из слоя domain.
  - **repositories**: Реализация репозитория.
  - **datasources**: Источники данных (например, API или локальная база данных).

### Чистая архитектура

1. **Presentation**:
    - Включает экраны и виджеты, которые предоставляют интерфейс для взаимодействия с пользователем.
    - Каждый экран имеет свой блок (BloC), который управляет состоянием этого экрана.
   
2. **Domain**:
    - Содержит логику приложения и абстракции, не зависимые от фреймворков и инфраструктуры.
    - Реализует бизнес-правила, которые управляют взаимодействием с данными через use cases и репозитории.

3. **Data**:
    - Слой для взаимодействия с внешними источниками данных.
    - Здесь расположены конкретные реализации репозиториев, взаимодействующих с API или локальными хранилищами посредством источников данных (datasources).

## Реализация экрана списка Todos

### Структура экрана списка задач

Экран списка задач состоит из следующих компонентов:

- **Скоуп зависимостей**: Каждый экран имеет свой собственный скоуп зависимостей, обеспечивающий инъекцию необходимых зависимостей.
- **BloC**: Экран использует **BlocProvider** для создания и управления состоянием.
- **UI**: Визуальная часть экрана, включая отображение списка задач и обработку различных состояний (загрузка, ошибка, успешная загрузка).

### BloC экрана списка Todos

Мы используем одну основную блок-логику для экрана списка задач. Блок отвечает за загрузку всех задач через use case. 

Каждый блок имеет состояние, которое может быть одним из следующих:

- **InitialState** — первичное состояние блока.
- **LoadingState** — когда данные загружаются.
- **DataState** — когда данные успешно загружены.
- **SuccessState** — когда действие выполнено успешно.
- **ErrorState** — когда произошла ошибка.

Для обработки эвентов мы используем sealed-классы и фабричные конструкторы, что упрощает переход между состояниями.

### UseCase для получения списка Todos

Use case представляет собой операцию, которая может быть выполнена пользователем. В случае с загрузкой списка задач, use case обращается к репозиторию, получает данные и передает их в блок.

### Репозитории

Репозиторий представляет собой абстракцию для доступа к данным и является интерфейсом для реализации слоя данных.

**TodoRepository (Domain слой)**: Определяет методы для работы с задачами.

**TodoRepositoryImpl (Data слой)**: Реализует методы доступа к данным, например, через API или локальную базу данных.

### Датасорсы

**Этот слой отвечает за взаимодействие с внешними источниками данных.**

Здесь мы используем датасорс с фейковым хранилищем. В реальном проекте у нас был бы датасорс, в котором мы бы обращались к API или локальной Базе Данных.

## Экран создания / редактирования Todo

Экран создания или редактирования задачи предоставляет форму с полями для ввода текста, переключателем для состояния задачи и кнопкой для сохранения. В режиме редактирования форма отображает текущие данные задачи и позволяет их изменять.

### BloC для экрана создания / редактирования Todo

Здесь мы используем три блока для разделения логики:

- **InitBloc (Блок инициализации)**:  
    Его единственная ответственность — загрузить данные задачи при открытии экрана редактирования. Этот блок выполняет работу по извлечению задачи из репозитория (например, из базы данных или через API). Он также загружает данные, необходимые для первоначального отображения формы.
    
    **Почему это важно?** Задача может иметь разные способы извлечения данных, например, для разных типов пользователей или разных источников (локальная база данных или сервер). Отделение этой логики в отдельный блок упрощает тестирование и масштабируемость, а также облегчает поддержку кода, потому что изменения в механизме загрузки не повлияют на остальные блоки экрана.
    
- **FormBloc (Блок формы)**:  
    Этот блок управляет состоянием формы редактирования. Его ответственность заключается в обработке изменений, которые пользователь вносит в форму (например, изменения в тексте задачи, переключение состояния выполнения и т.д.). Он отслеживает, что именно изменилось в задаче, и управляет состоянием этих изменений.
    
    **Почему это важно?** Разделение логики редактирования в отдельный блок позволяет централизованно отслеживать состояние формы. Блок имеет чёткую задачу — управлять данными формы и синхронизировать эти данные с внутренним состоянием экрана. Это делает код чище и удобнее для тестирования: мы можем легко проверить логику обработки изменения данных без необходимости взаимодействовать с другими частями экрана.
    
- **SubmitBloc (Блок отправки/сохранения)**:  
    Когда пользователь нажимает кнопку "Сохранить" или "Удалить", этот блок обрабатывает действие, выполняя необходимые операции над данными: сохранение, обновление или удаление задачи. SubmitBloc взаимодействует с репозиторием для выполнения этих операций.
    
    **Почему это важно?** Этот блок изолирует логику сохранения и удаления от остальной части экрана. Он отвечает за выполнение конкретных действий с данными (например, отправка данных на сервер или сохранение в базе данных) и обработку состояний, связанных с этими операциями (например, успешное сохранение или ошибка).

## Вывод

Почему эта архитектура является хорошим выбором для Flutter-приложений:**

- **Ясное разделение ответственности:** Каждый слой имеет четко определенную роль, что упрощает понимание кода и его поддержку.
- **Высокая тестируемость:** Каждый слой можно тестировать независимо, что повышает качество кода.
- **Масштабируемость:** Легко добавлять новые функции и изменять существующие без существенной переработки всего приложения.
- **Поддерживаемость:** Структура проекта становится более понятной, что облегчает работу с проектом в долгосрочной перспективе.
- **Повышение качества кода:** Такая архитектура способствует написанию более чистого и структурированного кода.
- **Соответствие принципам SOLID:** Принципы SOLID помогают создавать более гибкий и поддерживаемый код.

**Дополнительные преимущества:**
- **Упрощенный поиск файлов по проекту**
- **Использование паттернов проектирования:** Такая структура позволяет эффективно применять различные паттерны проектирования.
- **Улучшение сотрудничества в команде:** Четкая архитектура облегчает совместную работу разработчиков.
